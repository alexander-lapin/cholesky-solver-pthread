\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage[left=1cm, right=1cm, top=1cm, bottom=2cm]{geometry}
\author{Лапин Александр}
\title{Домашняя работа №1}
\usepackage{graphicx}
\DeclareMathOperator{\sgn}{sgn}

\begin{document}

\newcommand{\parw}[2]{\dfrac{\partial #1}{\partial #2}}
\newcommand{\pl}{p_{\lambda}}
\newcommand{\pa}{p_{a}}
\newcommand{\pgm}{p_{m, \sigma^2}}
\newcommand{\pma}{p_{M, a}}
\newcommand{\xseqn}{x_1, \ldots, x_n}
\renewcommand{\le}{\leqslant}


\binoppenalty=10000
\relpenalty=10000
\newcommand*{\hm}[1]{#1\nobreak\discretionary{}%
{\hbox{$\mathsurround=0pt #1$}}{}}

\begin{center}
\large\textbf{Блочный метод Холецкого решения системы линейных уравнений}
\end{center}

\begin{flushright}
Лапин Александр

lapinra@gmail.com

2011
\end{flushright}

\noindent\underline{Теоретическая часть:}
\par
Метод Холецкого применяется для решения уравнений вида $A x = b$, где $A$ - самосопряженная матрица. В дальнейшем рассматривается случай, когда все числа вещественные.
\par
Метод основан на представлении матрицы $A$ в виде $A = R^T D R$, где $R$ - верхнетреугольная матрица с положительными элементами на главной диагонали, а $D$ - диагональная матрица с равными по модулю единице элементами.
\par
Пусть $A = (a_{ij})$, $R = (r_{ij})$, $D = (d_{ij})$, $i, j = 1, \ldots, n$. Тогда, из равенства $A = R^T D R$, имеем:
$$
a_{ij} = \sum_{k = 1}^i r_{ki} d_{kk} r_{k j},
$$
Отсюда:
$$
r_{ii} d_{ii} r_{ij} = a_{ij} - \sum_{k = 1}^{i-1} r_{ki} d_{kk} r_{kj}
$$

$$
r_{ij} = d_{ii}^{-1} r_{ii}^{-1} (a_{ij} - \sum_{k = 1}^{i-1} r_{ki} d_{kk} r_{kj}) \eqno (1)
$$

$$
r_{ii} d_{ii} r_{ii} = a_{ii} - \sum_{k = 1}^{i-1} r_{ki} d_{kk} r_{k i} \eqno (2)
$$

$$
r_{ii} = \sqrt{|a_{ii} - \sum_{k = 1}^{i-1} r_{ki} d_{kk} r_{k i}|}
$$

$$
d_{ii} = \sgn(a_{ii} - \sum_{k = 1}^{i-1} r_{ki} d_{kk} r_{k i})
$$

\par
Построение матрицы $R$ происходит последовательным вычислением её элементов $r_{ij}$ в порядке возрастания $i$.

\par\smallskip
Аналогичным образом работает блочный метод Холецкого. Пусть $A = (A_{ij})$, $R = (R_{ij})$, $D = (D_i)$. Тогда аналогами формул $(1)$ и $(2)$ будут являться:
$$
R_{ij} = D_i^{-1} (R_{ii}^T)^{-1} \cdot (A_{ij} - \sum_{k = 1}^{i-1} R_{ki}^T D_k R_{kj}) \eqno (1')
$$

$$
R_{ii}^T D_i R_{ii} = A_{ii} - \sum_{k = 1}^{i-1} R_{ki}^T D_k R_{ki} \eqno (2')
$$

Из $(2')$ получаем, что $R_{ii}$ и $D_i$ можно найти, применяя метод Холецкого к матрице $(A_{ii} - \sum\limits_{k = 1}^{i-1} R_{ki}^T D_k R_{ki})$

\par
Элементы блочной матрицы $R = (R_{ij})$, так же, как и в неблочном методе, вычисляются в порядке возрастания индексов $i$.

\par
\smallskip
После разложения $A$ в произведение $A = R^T D R$, решаются две системы уравнений $D R y = b$ и $R^T x = y$.

\par\bigskip
\noindent\underline{Необходимые операции:}
\par
1.Решение системы $D R x = b$ и $R^T x = b$, где $R$ - верхнетреугольная матрица
\par
\noindent Из $(1')$:
\par
2. Умножение матриц вида $AB$, $A D$, $A D B$, где $D$ - диагональная матрица
\par
3. Вычитание одной матрицы из другой
\par
4. Нахождение обратной матрицы для нижнетреугольной матрицы
\par
\noindent Из $(2')$:
\par
5. Применение неблочного метода Холецкого к матрице

\par\bigskip
\noindent\underline{Организация хранения матриц:}
\par
Исходную матрицу $A$ можно хранить в виде верхнетреугольной матрицы (хранить только элементы $a_{ij}$, $i \le j$). Элементы матрицы $R$ можно записывать на соответсвующие места матрицы $A$. Матрицу $D$ можно хранить в виде вектора $D = (d_{11}, \ldots, d_{nn})$.

\par\bigskip
\noindent\underline{Особенности реализации:}
\par
Для эффективной работы алгоритма необходимо организовать наиболее подходящим образом хранение блоков матрицы, порядок выполнения операций в вышеуказанных функциях и сам порядок выполнения этих функций. Рассмотрим особенности реализаций каждой из них:
\par\smallskip\noindent
1. Решение системы $D R x = b$ и $R^T x = b$, где $R$ - верхнетреугольная матрица.
\par
а) При решении таких систем нет необходимости изменять матрицу $R^T$ ($R$)
\par
б) Матрицы стоит хранить так, чтобы при решении системы внутренний цикл пробегал по строке

\par\smallskip\noindent
2. Умножение матриц вида $AB$, $A D$, $A D B$, где $D$ - диагональная матрица
\par
Переумножать матрицы надо так, чтобы внутренний цикл пробегал по строке
\par
Например:
\begin{verbatim}
for k = 1, .., m
  for i = 1, .., n
    for j = 1, .., m
      c[i, j] += a[i, k] * b[k, j]
\end{verbatim}

\par\smallskip\noindent
3. Вычитание одной матрицы из другой
\par
Операции надо производить по строкам

\par\smallskip\noindent
4. Нахождение обратной матрицы для нижнетреугольной матрицы
\par
Чтобы внутренний цикл бежал по строке, можно вычитать из $i$-ой строки вышестоящие строки

\par\smallskip\noindent
5. Применение неблочного метода Холецкого к матрице
\par
Так как $i$-ая строка $R$ зависит только от вышестоящих, то внутренний цикл в формуле $(1)$ можно сделать по индексу $j$

\par\bigskip\noindent
Алгоритм блочного алгоритма Холецкого:
\par
1. Пусть $i-1$ строка блочной матриц $R$ и $D$ уже посчитаны. 
\par
2. Переберем $k$ от $1$ до $(i-1)$, $j$ от $i$ до количества блоков в строке.
\par
Для фиксированных $k$, $j$:
$$A' = R^T_{ki},$$ 
$$B' = R_{kj},$$ 
$$C' = R^T_{ki} D R_{kj},$$
$$A_{ij} = A_{ij} - C'$$
\par
3. Вычисляем $R_{ii}$ и $D_{i}$ неблочным методом Холецкого от $A_{ii}$.
\par
4. Ищем обратную матрицу к $R_{ii} D_i$: 
$$A' = R_{ii} D_i$$
$$B' = (A')^{-1}$$
\par
5. Умножаем $i$-ую строку матрицы $A$, начиная с $(i+1)$-го элеметна, на $B'$.
\par
6. $i$-ые строки блочных матриц $R$ и $D$ посчитаны, переходим к $(i+1)$-ой.
\par
7. После вычисления $R$ и $D$, решаем $D R y = b$.
\par
8. Решаем $R^T x = y$.

\par\bigskip
\noindent\underline{Параллельный алгоритм:}

Последовательный блочный алгоритм выглядит следующим образом:
\begin{verbatim}
for i = 1, .., n
{
..for j = i, .., n
....for k = 1, .., i-1
......Вычесть из блока A[i][j] произведение A[k][i]*A[k][j]

..Посчитать A[i][i], D[i]
..Посчитать обратный блок к A[i][i]

..for j = i+1, .. n
....Умножить блок A[i][j] на обратный к A[i][i]
}	
\end{verbatim}

Пусть теперь есть $p$ потоков. На $i$-ом шаге внешнего цикла, разобьем множество всех блоков, которые на этом шагу должны быть посчитаны, на $p$ частей. И пусть в кадом потоке считаются только соответственные блоки $A_{ij}$. Тогда, единственным местом, к которому обращаются все потоки, будет $i$-ый столбец блоков \textbf{(A)}, включая блок $A_{ii}$ \textbf{(B)}.

Коллизии в случае \textbf{(A)} можно значительно уменьшить путем запуска цикла по $k$ в каждом потоке с разными начальными значениями. В случае \textbf{(B)} можно для каждого потока скопировать обратную к $A_{ii}$ в отдельный блок (для каждого потока свой).

Чтобы перейти к умножению на обратный блок, необходимо что бы к этому моменту был посчитан блок $A_{ii}$. Для этого можно сделать перед вторым циклом по $j$ точку синхронизации. Понятно, что чтобы перейти к следующей строке блоков (к $i+1$-ому шагу внешнего цикла), также необходима точка синхронизации.

Пусть $t$ - номер текущего потока, $p$ - количество потоков, тогда получаем следующую схему параллельного алгоритма для одного потока:
\begin{verbatim}
for i = 1, .., n
{
..for j = i + t, .., n, на каждом шаге j += p
....for k = (i + p - 1) / p * t, .., (i + p - 1) / p * t - 1, на каждом шаге k = k%i + 1
......Вычесть из блока A[i][j] произведение A[k][i]*A[k][j]

..Если текущий поток тот, в котором считалось A[i][i]
..{
....Посчитать A[i][i], D[i]
....Посчитать обратный блок к A[i][i]
..}

..Точка синхронизации

..Скопировать обратную к A[i][i]

..for j = i + 1 + t, .. n, на каждом шаге j += p
....Умножить блок A[i][j] на обратный к A[i][i]

..Точка синхронизации
}	
\end{verbatim}


\end{document}